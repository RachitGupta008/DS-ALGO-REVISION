class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
         UnionFind uf = new UnionFind(graph.length);
        // Your code will replace this placeholder return statement
        int n = graph.length;
        int[] count = new int[n];
        Arrays.sort(initial);
        

        for(int i=0;i<graph.length;i++){

            for(int j=0;j<graph[0].length;j++){

                if(i!=j && graph[i][j]==1){
                    uf.Union(i, j);
                }

                
            }
        }

        int max = Integer.MIN_VALUE;
        int ans = -1;
        for (int node: initial)
            count[uf.findParent(node)]++;

        for(int i=initial.length-1;i>=0;i--){
            int root = uf.findParent(initial[i]);
            if(count[root]==1 && uf.size[root]>=max){
                max = uf.size[root];
                ans = i;
            }

        }

        System.out.println(ans);
        if (ans == -1) {
            ans = Integer.MAX_VALUE;
            for (int node: initial){
                ans = Math.min(ans, node);
            }
            return ans;
        }

        return initial[ans];
    }


class UnionFind {
    int[] parents;
    int[] size;
    // Constructor
    public UnionFind(int n) {
        parents = new int[n];
        size = new int[n];
        for (int i = 0; i < n; i++) {
            parents[i] = i;
            size[i] = 1;
        }
    }
    // Function to find which subset a particular element belongs.
    public int findParent(int x) {
        if (parents[x] == x) {
            return x;
        }
        return parents[x] = findParent(parents[x]);
    }
    // Function to join two subsets into a single subset.
    public void Union(int x, int y) {
        int xParent = findParent(x);
        int yParent = findParent(y);
        if (xParent != yParent) {
            parents[xParent] = yParent;
            size[yParent] += size[xParent];
        }
    }
}
}
